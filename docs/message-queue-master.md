# Message Queue Master

## 基础篇

### Chapter-03 消息模型

- 两种消息模型
  - 队列模型（消息被消费实质就是消息被从队列中移除，所以一份消息被消费一次后就不存在了）。其实可以引入consumer offset的概念，来为每种消费者维护一个偏移量去消费数据，而不是直接移除数据
  - 发布-订阅模型
  - 两种消息模型最大的区别在于**一份消息能不能被多次消费**
  - <img src="images/queue-model.jpg" alt="queue-model" style="zoom:15%;" />
  - <img src="images/publish-subscribe-model.jpg" alt="publish-subscribe-model" style="zoom:15%;" />
- 几乎所有的消息队列产品都采用朴素的“请求-确认”（ACK）机制来保证消息不丢失。在生产者端，若生产者没有收到服务端的确认或失败响应，则会重发；在消费者端，若服务端没有收到消费者的消费确认，则会向消费者端重新推送这条消息

------



##### RabbitMQ的消息模型

<img src="images/rabbitmq-exchange.jpg" alt="rabbitmq-exchange" style="zoom:15%;" />

RabbitMQ使用的是**队列模型**，为了解决队列模型中**一份消息只能被消费一次**的问题，RabbitMQ中引入了Exchange的概念：生产者只负责将消息投递到Exchange，然后再根据Exchange上配置的策略来决定投递到哪些消费者

在RabbitMQ的每个队列（queue）都维护了一份完整的消息数据，有多少组消费者，就有多少个queue。通过这种Exchange-Queue的设计，RabbitMQ解决了“一份消息只能被消费一次”的问题，但是这个问题其实在“发布-订阅”模型中天然满足；一组消费者只能对应一个Queue，其并发性能与RocketMQ相比不足

##### RocketMQ的消息模型

<img src="images/rocketmq-model.jpg" alt="rocketmq-model" style="zoom:15%;" />

RocketMQ中有了主题（topic）后为什么还有队列（queue）的概念，队列在RocketMQ中发挥了什么作用？

- 在消息队列中为了保证消息的有序性，在一条消息被成功消费之前，下一条消息是不能被同一消费组（consumer group）内的其他消费者实例消费的，否则就会出现空洞，违背了有序性原则

  在同一时刻，每个主题（topic）只能被同一消费组内的一个消费者实例消费，直到这份消息被消费成功之前，同一消费组内的其他实例都只能干看着，因此无法通过水平扩展消费组内的实例数来提升消费端的吞吐量

  RocketMQ中在主题（topic）下引入队列之后，每个主题下的多个队列可以被同一消费组（consumer group）下的多个消费者实例并行消费，主题下的队列相当于分片，将主题中的消息数据分散存储在多个队列中

  RocketMQ中**不保证主题的整体有序，只保证单个队列内的消息有序性**

RocketMQ中，topic中一份消息可以被不同消费组多次消费，所以消息并不会立即删除，这就需要为每个消费组在每个队列上维护一个消费位置（**consumer offset**），这个位置之前的消息都被消费过，这个位置之后的消息都未被消费过，每成功消费一条消息offset就加一。在使用消费队列的时候，**丢消息的原因大多数都是消费位置处理不当导致的**（如去拉消息的时候，请求参数offset越过了未被消费过的消息，导致有部分未消费的消息未被拉取到；或者是）

##### Kafka的消息模型

Kafka的消息模型与RocketMQ的消息模型基本一致，唯一不同点就是Kafka中用“分区（Partition）”的概念替换了RocketMQ中“队列（Queue）”的概念

##### 思考题

RocketMQ中，在消费的时候，为了保证消息不丢失和消息的有序性，每个队列只能串行消费，无法做到并发，否则会出现消费空洞的问题，如果放宽一下限制，不要求严格顺序，能够做到单个队列的并行消费呢？

- 可以做到，RocketMQ中就有此种机制（需要手动配置开启），offset会越过尚未进行消费成功确认（ack）的消息加一；如拉数据/半消息

  这种情况下，消息消费就是个出队操作，而非等待消费端ack后再出队了，这样势必会造成消息的丢失，所以需要有一定的补偿机制，如消息的重传和持久化等



### chapter-04 如何利用事物消息实现分布式事务？

一个严格的事务实现应该具备4个属性：原子性、一致性、隔离型、持久性，即ACID

- 原子性是指一个事务内的所有操作要么全部成功，要么全部失败
- 一致性是指事务提交前后，涉及到的所有数据的总体属性应该保持不变，在预期内，不能出现事务提交前后的数据出现缺失对不上的情况
- 隔离性是指事务与事务之间的操作互不干涉，互不影响，各自独立
- 持久性是指在事务提交之后，后续的操作和故障不会影响到事务提交的结果



事务消息主要适用于那些需要异步更新数据，对数据实时性要求不太高的场景



##### 以电商系统中的下单为例来说明如何利用事务消息实现分布式事务

- 下单总的分为两步：创建订单，清空购物车
- **清空购物车这一步的结果无法影响到创建订单，只以创建订单的结果作为整体事务的结果**
- 具体流程：
  1. 首先订单系统向mq发送一个半消息（半消息此时无法被消费，对订阅者不可见，offset会跳过）
  2. 开启订单系统本地事务
  3. 执行本地事务，创建订单
  4. 根据本地事务执行结果来提交/回滚半消息

- <img src="images/distribute-transaction-sample.jpg" alt="distribute-transaction-sample" style="zoom:15%;" />
- 考虑以上几步每一步可能出现异常的情况
  - 第一步出现异常则整体事务失败
  - 第三步失败则会滚本地事务并进入第四步回滚半消息
  - **第四步提交/回滚半消息失败，这里会有问题，如何解决？**
    - kafka：简单粗暴，直接抛出异常给我们，让用户自行处理，我们可以反复重试或者删除订单补偿
    - RocketMQ：用户提供一个反查接口，RocketMQ会定时去查询反查接口，根据接口结果再对半消息做提交/回滚处理



##### RocketMQ事务消息中的反查机制

在RocketMQ中，为了解决提交/回滚半消息时失败的问题，**增加了事务反查机制**

Producer会实现一个反查接口，如果Producer在提交/回滚半消息时发生网络异常，导致RocketMQ的Broker没有接收到提交/回滚的请求，那么Broker会定时去Producer上去反查这个半消息对应的本地事务的结果，然后根据本地事务的结果再决定提交/回滚半消息

**反查机制的实现并不依赖消息的发送方**，它查询的是数据库数据，也就是说即使发送消息的那台机器当机了，RocketMQ也可以反查其他Producer来获取本地事务的执行结果

<img src="images/rocketmq-transaction-message.jpg" alt="rocketmq-transaction-message" style="zoom:15%;" />



##### RocketMQ的事务消息是不是完整的实现了事务的四个特性ACID？

只实现了一致性、持久性以及部分原子性，未实现隔离性

- 未实现隔离性：当本地事务提交成功后，如果用户取消并删除了订单，那么如果出现了需要进行事务反查的情况，那么此时反查接口里查询到此订单不存在，从而回滚半事务消息导致整体事务失败；所以其他的事务会干扰到当前事务

- 部分原子性：当本地事务成功时，事务消息一定成功（即使提交失败也会通过反查来最终提交成功），当本地事务失败时，事务消息一定失败（即使回滚失败也会通过反查来最终回滚成功），而事务消息的提交失败/回滚失败根本不会影响到本地事务，所以在事务消息实现的分布式事务中，只以本地事务的成功/失败结果来作为整体分布式事务的成功失败

  并且当购物车系统的清空购物车本地事务失败时也无法影响到订单系统的本地事务结果



## 进阶篇

### chapter-09 学习开源代码如何入手

- 阅读源码的顺序
  1. 阅读开源项目的灵魂（某篇学术期刊/论文），一般可以从官方文档中找到
  2. 阅读官方文档（Quick Start，Introduction/Basic Concepts，Use case，EcoSystem），了解开源项目的一些关键概念（一般都是开发者自己发明的，e.g. Kafka Partition）及其应用场景
  3. 提出问题（提不出问题怎么办？看官方文档，过程中思考，提出问题）
  4. 带着问题去看官方文档（找一下官方是否有对应的实现文档，DESIGN，IMPLEMENTATION，Improvement Proposal（新功能拓展文档，非核心的更细节功能在此描述）），然后看源码，最后得到答案
     - *不要直接从main方法开始学习源码，源码不是一个线性的存在*
  5. 在带着问题看源码找到答案后，画出核心类图&时序图（or流程图）
  6. 将原理细节用文字描述出来
  7. 点成线
  8. 线成网
  9. 实际应用
  10. 官方文档
  11. 灵魂
- 阅读源码的顺序总的来说是一个整体-细节-整体的过程
- **带着问题去看源码，最好是带着问题的答案去看源码（这就需要先从官方文档找），思考知识点之间的关联，多写总结**

### chapter-10 如何使用异步设计提高系统性能

异步性能虽好，但不能滥用，**只有业务逻辑简单且需要超高吞吐量，或需要长时间等待资源的地方，才使用异步模型**

以转账为例，涉及到三个系统：调用端 -> 转账服务 -> 资金账户服务，两次调用（process1，process2）

- 如果采用同步调用，则整条调用流程都会处于等待中，直到最后一个节点-资金账户服务处理完成，才能终结掉整条处理流程
- 如果采用**<u>异步调用，则每个节点都只需要在接受请求后将业务处理逻辑丢到下面的线程池去处理，然后直接返回就行</u>**，调用节点之间不再存在强依赖（不再等待上游业务逻辑执行完成），提高了整条链路的请求吞吐量。异步调用不仅提高了本节点的请求吞吐量而且因为其请求响应速度的提高，也带动了下游的吞吐量提升
  - <img src="images/transfer-sync.jpg" alt="transfer-sync" style="zoom:15%;" />
  - <img src="images/transfer-async.jpg" alt="transfer-async" style="zoom:15%;" />

在设计异步模型时，有几个点需要注意：

- 每台机器总的线程数量是有上限的
- 并不是线程数越多越好，太多会造成频繁的cpu上下文切换反而拖低了性能，太少会造成cpu时间片工作不饱和。例如：我们有1台电脑，1个程序员，每天工作8小时，我们想提高电脑利用率，使用3个程序员三班倒，这时效率最高，如果直接使用1000个程序员，那么就会产生频繁的工作交接，每个程序员的利用率会变得很低
- 要根据业务逻辑是cpu密集型还是I/O密集型来设置线程池的线程数，cpu密集型一般设置2*cpu核数线程数，保证cpu跑满，I/O密集型一般设置cpu核数个线程数，避免不必要的频繁cpu上下文切换



异步调用的设计理念

- **<u>异步回调机制的本质就是通过减少线程请求等待时间（空等待，不会占用时间片，所以长时间的等待会造成cpu都处于闲置状态，但新的请求就是进不来（因为线程被打满了））来提高cpu利用率</u>**
  - 如A调用B，B接收请求耗时1s，处理业务逻辑耗时9s，整个过程耗时10s，假设机器的线程数上限是10000，某个时刻有10000个请求过来，若采用同步：那么在后续整整10s内只能一直处理接收的这10000个请求，其qps也就是1000/s；若采用异步回调：我们将请求处理线程池设为9999，业务逻辑处理线程池设为1，那么我们一秒能接收相应9999个请求，qps也就是9999/s
- 具体做法是用少数线程响应业务请求，但处理时这些线程并不真正调用业务逻辑代码，而是简单的把业务处理逻辑扔到另一个专门执行业务逻辑代码的线程后就返回了，故不会有任何等待(CPU时间片浪费)。专门执行业务逻辑的线程可能会由于IO慢导致上下文切换而浪费一些CPU时间片，但这已经不影响业务请求的响应了，而业务逻辑执行完毕后会把回调处理逻辑再扔到专门执行回调业务逻辑的线程中，这时的执行业务逻辑线程的使命已完成，线程返回，然后会去找下一个需要执行的业务逻辑，这里也没有任何等待。回调业务处理线程也是同理
- 以上与《摩登时代》里的卓别林很像，每个人只做自己的那点事(卓别林只拧螺丝)。有的线程只负责响应请求(放螺丝)，有的线程只负责执行业务逻辑(拧螺丝)，有的线程只负责执行回调代码(敲螺丝)，完成后就返回并继续执行下一个相同任务(拧完这个螺丝再找下一个需要拧的螺丝)，没有相互依赖的等待(放螺丝的不等螺丝拧好就直接放下一个螺丝)
- 有利就有弊，分开后是不用等别人了，但想知道之前的步骤是否已经做好了就难了。比如螺丝没有拧紧就开始敲，会导致固定不住。如果发现螺丝没拧好，敲螺丝的人就要和工头说这块板要返工，螺丝取下，重新放，重新拧，之后才能敲
- 个人感觉把关联性强且无需长时间等待的操作(如大量磁盘或网络IO)打包成同步，其他用异步，这样可以在规避CPU时间片浪费的同时兼顾了一致性，降低了补偿的频率和开销



在Java中比较常用的异步框架

- Java8中的[CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)（简单实用）
- ReactiveX中的[RxJava](https://github.com/ReactiveX/RxJava)（功能强大更复杂）



简单的说，**异步思想就是，当我们要执行一项比较耗时的操作时，不去等待操作结束，而是给这个操作一个命令：“当操作完成后，接下来去执行什么”**

使用异步编程模型，虽然并不能加快程序本身的速度，但可以减少或者避免线程等待，**只用很少的线程就可以达到超高的吞吐能力**



### chapter-11