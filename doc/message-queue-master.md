# Message Queue Master

## 基础篇

### Chapter-03 消息模型

- 两种消息模型
  - 队列模型（消息被消费实质就是消息被从队列中移除，所以一份消息被消费一次后就不存在了）。其实可以引入consumer offset的概念，来为每种消费者维护一个偏移量去消费数据，而不是直接移除数据
  - 发布-订阅模型
  - 两种消息模型最大的区别在于**一份消息能不能被多次消费**
  - <img src="image/queue-model.jpg" alt="queue-model" style="zoom:15%;" />
  - <img src="image/publish-subscribe-model.jpg" alt="publish-subscribe-model" style="zoom:15%;" />
- 几乎所有的消息队列产品都采用朴素的“请求-确认”（ACK）机制来保证消息不丢失。在生产者端，若生产者没有收到服务端的确认或失败响应，则会重发；在消费者端，若服务端没有收到消费者的消费确认，则会向消费者端重新推送这条消息

------



##### RabbitMQ的消息模型

<img src="image/rabbitmq-exchange.jpg" alt="rabbitmq-exchange" style="zoom:15%;" />

RabbitMQ使用的是**队列模型**，为了解决队列模型中**一份消息只能被消费一次**的问题，RabbitMQ中引入了Exchange的概念：生产者只负责将消息投递到Exchange，然后再根据Exchange上配置的策略来决定投递到哪些消费者

在RabbitMQ的每个队列（queue）都维护了一份完整的消息数据，有多少组消费者，就有多少个queue。通过这种Exchange-Queue的设计，RabbitMQ解决了“一份消息只能被消费一次”的问题，但是这个问题其实在“发布-订阅”模型中天然满足；一组消费者只能对应一个Queue，其并发性能与RocketMQ相比不足

##### RocketMQ的消息模型

<img src="image/rocketmq-model.jpg" alt="rocketmq-model" style="zoom:15%;" />

RocketMQ中有了主题（topic）后为什么还有队列（queue）的概念，队列在RocketMQ中发挥了什么作用？

- 在消息队列中为了保证消息的有序性，在一条消息被成功消费之前，下一条消息是不能被同一消费组（consumer group）内的其他消费者实例消费的，否则就会出现空洞，违背了有序性原则

  在同一时刻，每个主题（topic）只能被同一消费组内的一个消费者实例消费，直到这份消息被消费成功之前，同一消费组内的其他实例都只能干看着，因此无法通过水平扩展消费组内的实例数来提升消费端的吞吐量

  RocketMQ中在主题（topic）下引入队列之后，每个主题下的多个队列可以被同一消费组（consumer group）下的多个消费者实例并行消费，主题下的队列相当于分片，将主题中的消息数据分散存储在多个队列中

  RocketMQ中**不保证主题的整体有序，只保证单个队列内的消息有序性**

RocketMQ中，topic中一份消息可以被不同消费组多次消费，所以消息并不会立即删除，这就需要为每个消费组在每个队列上维护一个消费位置（**consumer offset**），这个位置之前的消息都被消费过，这个位置之后的消息都未被消费过，每成功消费一条消息offset就加一。在使用消费队列的时候，**丢消息的原因大多数都是消费位置处理不当导致的**（如去拉消息的时候，请求参数offset越过了未被消费过的消息，导致有部分未消费的消息未被拉取到；或者是）

##### Kafka的消息模型

Kafka的消息模型与RocketMQ的消息模型基本一致，唯一不同点就是Kafka中用“分区（Partition）”的概念替换了RocketMQ中“队列（Queue）”的概念

##### 思考题

RocketMQ中，在消费的时候，为了保证消息不丢失和消息的有序性，每个队列只能串行消费，无法做到并发，否则会出现消费空洞的问题，如果放宽一下限制，不要求严格顺序，能够做到单个队列的并行消费呢？

- 可以做到，RocketMQ中就有此种机制（需要手动配置开启），offset会越过尚未进行消费成功确认（ack）的消息加一；如拉数据/半消息

  这种情况下，消息消费就是个出队操作，而非等待消费端ack后再出队了，这样势必会造成消息的丢失，所以需要有一定的补偿机制，如消息的重传和持久化等



### chapter-04 如何利用事物消息实现分布式事务？

一个严格的事务实现应该具备4个属性：原子性、一致性、隔离型、持久性，即ACID

- 原子性是指一个事务内的所有操作要么全部成功，要么全部失败
- 一致性是指事务提交前后，涉及到的所有数据的总体属性应该保持不变，在预期内，不能出现事务提交前后的数据出现缺失对不上的情况
- 隔离性是指事务与事务之间的操作互不干涉，互不影响，各自独立
- 持久性是指在事务提交之后，后续的操作和故障不会影响到事务提交的结果



事务消息主要适用于那些需要异步更新数据，对数据实时性要求不太高的场景



##### 以电商系统中的下单为例来说明如何利用事务消息实现分布式事务

- 下单总的分为两步：创建订单，清空购物车
- **清空购物车这一步的结果无法影响到创建订单，只以创建订单的结果作为整体事务的结果**
- 具体流程：
  1. 首先订单系统向mq发送一个半消息（半消息此时无法被消费，对订阅者不可见，offset会跳过）
  2. 开启订单系统本地事务
  3. 执行本地事务，创建订单
  4. 根据本地事务执行结果来提交/回滚半消息

- <img src="image/distribute-transaction-sample.jpg" alt="distribute-transaction-sample" style="zoom:15%;" />
- 考虑以上几步每一步可能出现异常的情况
  - 第一步出现异常则整体事务失败
  - 第三步失败则会滚本地事务并进入第四步回滚半消息
  - **第四步提交/回滚半消息失败，这里会有问题，如何解决？**
    - kafka：简单粗暴，直接抛出异常给我们，让用户自行处理，我们可以反复重试或者删除订单补偿
    - RocketMQ：用户提供一个反查接口，RocketMQ会定时去查询反查接口，根据接口结果再对半消息做提交/回滚处理



##### RocketMQ事务消息中的反查机制

在RocketMQ中，为了解决提交/回滚半消息时失败的问题，**增加了事务反查机制**

Producer会实现一个反查接口，如果Producer在提交/回滚半消息时发生网络异常，导致RocketMQ的Broker没有接收到提交/回滚的请求，那么Broker会定时去Producer上去反查这个半消息对应的本地事务的结果，然后根据本地事务的结果再决定提交/回滚半消息

**反查机制的实现并不依赖消息的发送方**，它查询的是数据库数据，也就是说即使发送消息的那台机器当机了，RocketMQ也可以反查其他Producer来获取本地事务的执行结果

<img src="image/rocketmq-transaction-message.jpg" alt="rocketmq-transaction-message" style="zoom:15%;" />



##### RocketMQ的事务消息是不是完整的实现了事务的四个特性ACID？

只实现了一致性、持久性以及部分原子性，未实现隔离性

- 未实现隔离性：当本地事务提交成功后，如果用户取消并删除了订单，那么如果出现了需要进行事务反查的情况，那么此时反查接口里查询到此订单不存在，从而回滚半事务消息导致整体事务失败；所以其他的事务会干扰到当前事务

- 部分原子性：当本地事务成功时，事务消息一定成功（即使提交失败也会通过反查来最终提交成功），当本地事务失败时，事务消息一定失败（即使回滚失败也会通过反查来最终回滚成功），而事务消息的提交失败/回滚失败根本不会影响到本地事务，所以在事务消息实现的分布式事务中，只以本地事务的成功/失败结果来作为整体分布式事务的成功失败

  并且当购物车系统的清空购物车本地事务失败时也无法影响到订单系统的本地事务结果



